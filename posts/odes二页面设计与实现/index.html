<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=content-language content="en">
<meta name=color-scheme content="light dark">
<meta name=author content="无生">
<meta name=description content="整体结构    网站按照之前在Everstring常用的前后端结构，后端只提供api，前端一个html从后端请求数据然后展示，用nginx讲两者的流量区分开来。本来前端需要gulp配置一通流水线工具的，但是折腾了一天也没有弄出个样子来，干脆放弃这些高端玩意，先把东西用最原始最简单的方法做出来，有需求了才有动力换新的方法。
后端实现    由于目前只有一个展示诗文正文的一个页面，所以api非常简单。一开始的版本如下：
@app.route(&#34;/odes-api/<int:id>&#34;) def get_ode_by_id(id): script = &#34;&#34;&#34; WITH s AS (SELECT * FROM odes where id = %s) SELECT row_to_json(s) FROM s; &#34;&#34;&#34; cu.execute(script, (id,)) res = cu.fetchall() if res is None: raise ValueError else: return jsonify(res[0]) 请求一个id的数据，把对应诗文的内容和相关的一些数据全部传输过去。这里错误处理暂时没有实现。
后来为了实现上一篇和下一篇的功能，考虑了一番决定还是通过这一个api把相邻两个诗文的数据一并传输过去，对应的sql语句为：
WITH s AS (SELECT * FROM odes where id in (%s, %s, %s)) SELECT array_to_json(array_agg(row_to_json(s))) FROM s; 这样一来，问题就在于前端如何知道哪个数据是自己的，哪个数据是相邻页面的，于是手工调整顺序，将请求的数据放在中间。于是丑陋的代码实现如下：
if (id == 1): res[0][0], res[0][1], res[0][2] = res[0][2], res[0][0], res[0][1] if (id == MAXID): res[0][0], res[0][1], res[0][2] = res[0][1], res[0][2], res[0][0] 但是这样会出现几个问题，第一个是顺序是由postgres默认决定的，程序没有做校验，也没有办法校验（各个数据一致，没有字段标识区别开），正确结果依赖于各个部分默契合作，这样显然是不合理的。第二个是传输查询的内容过多，然而很多信息是毫无必要的，减慢了页面的加载速度。所以重新设计如下：第一，不采用循环的方式，第一篇没有上一篇，最后一篇没有下一篇(一方面处理逻辑要简单很多，更主要的是这个功能确实无所谓)。第二，分两次查询，因为查询是在服务器本地进行的，查询两次代价并不大，第二次仅仅查询相邻篇章的标题。代码如下：">
<meta name=keywords content="blog,developer,personal">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Odes（二）页面设计与实现">
<meta name=twitter:description content="整体结构    网站按照之前在Everstring常用的前后端结构，后端只提供api，前端一个html从后端请求数据然后展示，用nginx讲两者的流量区分开来。本来前端需要gulp配置一通流水线工具的，但是折腾了一天也没有弄出个样子来，干脆放弃这些高端玩意，先把东西用最原始最简单的方法做出来，有需求了才有动力换新的方法。
后端实现    由于目前只有一个展示诗文正文的一个页面，所以api非常简单。一开始的版本如下：
@app.route(&#34;/odes-api/<int:id>&#34;) def get_ode_by_id(id): script = &#34;&#34;&#34; WITH s AS (SELECT * FROM odes where id = %s) SELECT row_to_json(s) FROM s; &#34;&#34;&#34; cu.execute(script, (id,)) res = cu.fetchall() if res is None: raise ValueError else: return jsonify(res[0]) 请求一个id的数据，把对应诗文的内容和相关的一些数据全部传输过去。这里错误处理暂时没有实现。
后来为了实现上一篇和下一篇的功能，考虑了一番决定还是通过这一个api把相邻两个诗文的数据一并传输过去，对应的sql语句为：
WITH s AS (SELECT * FROM odes where id in (%s, %s, %s)) SELECT array_to_json(array_agg(row_to_json(s))) FROM s; 这样一来，问题就在于前端如何知道哪个数据是自己的，哪个数据是相邻页面的，于是手工调整顺序，将请求的数据放在中间。于是丑陋的代码实现如下：
if (id == 1): res[0][0], res[0][1], res[0][2] = res[0][2], res[0][0], res[0][1] if (id == MAXID): res[0][0], res[0][1], res[0][2] = res[0][1], res[0][2], res[0][0] 但是这样会出现几个问题，第一个是顺序是由postgres默认决定的，程序没有做校验，也没有办法校验（各个数据一致，没有字段标识区别开），正确结果依赖于各个部分默契合作，这样显然是不合理的。第二个是传输查询的内容过多，然而很多信息是毫无必要的，减慢了页面的加载速度。所以重新设计如下：第一，不采用循环的方式，第一篇没有上一篇，最后一篇没有下一篇(一方面处理逻辑要简单很多，更主要的是这个功能确实无所谓)。第二，分两次查询，因为查询是在服务器本地进行的，查询两次代价并不大，第二次仅仅查询相邻篇章的标题。代码如下：">
<meta property="og:title" content="Odes（二）页面设计与实现">
<meta property="og:description" content="整体结构    网站按照之前在Everstring常用的前后端结构，后端只提供api，前端一个html从后端请求数据然后展示，用nginx讲两者的流量区分开来。本来前端需要gulp配置一通流水线工具的，但是折腾了一天也没有弄出个样子来，干脆放弃这些高端玩意，先把东西用最原始最简单的方法做出来，有需求了才有动力换新的方法。
后端实现    由于目前只有一个展示诗文正文的一个页面，所以api非常简单。一开始的版本如下：
@app.route(&#34;/odes-api/<int:id>&#34;) def get_ode_by_id(id): script = &#34;&#34;&#34; WITH s AS (SELECT * FROM odes where id = %s) SELECT row_to_json(s) FROM s; &#34;&#34;&#34; cu.execute(script, (id,)) res = cu.fetchall() if res is None: raise ValueError else: return jsonify(res[0]) 请求一个id的数据，把对应诗文的内容和相关的一些数据全部传输过去。这里错误处理暂时没有实现。
后来为了实现上一篇和下一篇的功能，考虑了一番决定还是通过这一个api把相邻两个诗文的数据一并传输过去，对应的sql语句为：
WITH s AS (SELECT * FROM odes where id in (%s, %s, %s)) SELECT array_to_json(array_agg(row_to_json(s))) FROM s; 这样一来，问题就在于前端如何知道哪个数据是自己的，哪个数据是相邻页面的，于是手工调整顺序，将请求的数据放在中间。于是丑陋的代码实现如下：
if (id == 1): res[0][0], res[0][1], res[0][2] = res[0][2], res[0][0], res[0][1] if (id == MAXID): res[0][0], res[0][1], res[0][2] = res[0][1], res[0][2], res[0][0] 但是这样会出现几个问题，第一个是顺序是由postgres默认决定的，程序没有做校验，也没有办法校验（各个数据一致，没有字段标识区别开），正确结果依赖于各个部分默契合作，这样显然是不合理的。第二个是传输查询的内容过多，然而很多信息是毫无必要的，减慢了页面的加载速度。所以重新设计如下：第一，不采用循环的方式，第一篇没有上一篇，最后一篇没有下一篇(一方面处理逻辑要简单很多，更主要的是这个功能确实无所谓)。第二，分两次查询，因为查询是在服务器本地进行的，查询两次代价并不大，第二次仅仅查询相邻篇章的标题。代码如下：">
<meta property="og:type" content="article">
<meta property="og:url" content="https://saukymo.github.io/posts/odes%E4%BA%8C%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2016-06-20T13:46:52+00:00">
<meta property="article:modified_time" content="2016-06-20T13:46:52+00:00">
<title>
Odes（二）页面设计与实现 · Coder
</title>
<link rel=canonical href=https://saukymo.github.io/posts/odes%E4%BA%8C%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/>
<link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin>
<link rel=stylesheet href=/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin=anonymous media=screen>
<link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16>
<link rel=apple-touch-icon href=/images/apple-touch-icon.png>
<link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png>
<meta name=generator content="Hugo 0.92.0">
</head>
<body class="preload-transitions colorscheme-auto">
<div class=float-container>
<a id=dark-mode-toggle class=colorscheme-toggle>
<i class="fa fa-adjust fa-fw" aria-hidden=true></i>
</a>
</div>
<main class=wrapper>
<nav class=navigation>
<section class=container>
<a class=navigation-title href=/>
Coder
</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle>
<i class="fa fa-bars fa-fw" aria-hidden=true></i>
</label>
<ul class=navigation-list>
<li class=navigation-item>
<a class=navigation-link href=/posts/>Blog</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/about/>About</a>
</li>
</ul>
</section>
</nav>
<div class=content>
<section class="container post">
<article>
<header>
<div class=post-title>
<h1 class=title>
<a class=title-link href=https://saukymo.github.io/posts/odes%E4%BA%8C%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/>
Odes（二）页面设计与实现
</a>
</h1>
</div>
<div class=post-meta>
<div class=date>
<span class=posted-on>
<i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2016-06-20T13:46:52Z>
June 20, 2016
</time>
</span>
<span class=reading-time>
<i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read
</span>
</div>
<div class=tags>
<i class="fa fa-tag" aria-hidden=true></i>
<span class=tag>
<a href=/tags/python/>Python</a>
</span>
<span class=separator>•</span>
<span class=tag>
<a href=/tags/html/>html</a>
</span>
<span class=separator>•</span>
<span class=tag>
<a href=/tags/bootstrap/>bootstrap</a>
</span>
<span class=separator>•</span>
<span class=tag>
<a href=/tags/javascript/>Javascript</a>
</span>
<span class=separator>•</span>
<span class=tag>
<a href=/tags/jquery/>Jquery</a>
</span>
<span class=separator>•</span>
<span class=tag>
<a href=/tags/css/>CSS</a>
</span>
<span class=separator>•</span>
<span class=tag>
<a href=/tags/%E8%AF%97%E7%BB%8F/>诗经</a>
</span></div>
</div>
</header>
<div>
<h2 id=整体结构>
整体结构
<a class=heading-link href=#%e6%95%b4%e4%bd%93%e7%bb%93%e6%9e%84>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>网站按照之前在Everstring常用的前后端结构，后端只提供api，前端一个html从后端请求数据然后展示，用nginx讲两者的流量区分开来。本来前端需要<code>gulp</code>配置一通流水线工具的，但是折腾了一天也没有弄出个样子来，干脆放弃这些高端玩意，先把东西用最原始最简单的方法做出来，有需求了才有动力换新的方法。</p>
<h2 id=后端实现>
后端实现
<a class=heading-link href=#%e5%90%8e%e7%ab%af%e5%ae%9e%e7%8e%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>由于目前只有一个展示诗文正文的一个页面，所以api非常简单。一开始的版本如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>@app.route(<span style=font-style:italic>&#34;/odes-api/&lt;int:id&gt;&#34;</span>)
<span style=font-weight:700>def</span> get_ode_by_id(id):
	script = <span style=font-style:italic>&#34;&#34;&#34;
</span><span style=font-style:italic>		WITH s AS (SELECT * FROM odes where id = </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>) SELECT row_to_json(s) FROM s;
</span><span style=font-style:italic>	&#34;&#34;&#34;</span>
	cu.execute(script, (id,))
	res = cu.fetchall()
	<span style=font-weight:700>if</span> res <span style=font-weight:700>is</span> <span style=font-weight:700>None</span>:
		<span style=font-weight:700>raise</span> <span style=font-weight:700>ValueError</span>
	<span style=font-weight:700>else</span>:
		<span style=font-weight:700>return</span> jsonify(res[0])
</code></pre></div><p>请求一个id的数据，把对应诗文的内容和相关的一些数据全部传输过去。这里错误处理暂时没有实现。</p>
<p>后来为了实现上一篇和下一篇的功能，考虑了一番决定还是通过这一个api把相邻两个诗文的数据一并传输过去，对应的sql语句为：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=font-weight:700>WITH</span> s <span style=font-weight:700>AS</span> (<span style=font-weight:700>SELECT</span> * <span style=font-weight:700>FROM</span> odes <span style=font-weight:700>where</span> id <span style=font-weight:700>in</span> (%s, %s, %s)) <span style=font-weight:700>SELECT</span> array_to_json(array_agg(row_to_json(s))) <span style=font-weight:700>FROM</span> s;
</code></pre></div><p>这样一来，问题就在于前端如何知道哪个数据是自己的，哪个数据是相邻页面的，于是手工调整顺序，将请求的数据放在中间。于是丑陋的代码实现如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>	<span style=font-weight:700>if</span> (id == 1):
		res[0][0], res[0][1], res[0][2] = res[0][2], res[0][0], res[0][1]
	<span style=font-weight:700>if</span> (id == MAXID):
		res[0][0], res[0][1], res[0][2] = res[0][1], res[0][2], res[0][0]

</code></pre></div><p>但是这样会出现几个问题，第一个是顺序是由postgres默认决定的，程序没有做校验，也没有办法校验（各个数据一致，没有字段标识区别开），正确结果依赖于各个部分默契合作，这样显然是不合理的。第二个是传输查询的内容过多，然而很多信息是毫无必要的，减慢了页面的加载速度。所以重新设计如下：第一，不采用循环的方式，第一篇没有上一篇，最后一篇没有下一篇(一方面处理逻辑要简单很多，更主要的是这个功能确实无所谓)。第二，分两次查询，因为查询是在服务器本地进行的，查询两次代价并不大，第二次仅仅查询相邻篇章的标题。代码如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql>	<span style=font-weight:700>WITH</span> s <span style=font-weight:700>AS</span> (<span style=font-weight:700>SELECT</span> title <span style=font-weight:700>FROM</span> odes <span style=font-weight:700>where</span> id <span style=font-weight:700>in</span> (%s, %s)) <span style=font-weight:700>SELECT</span> array_to_json(array_agg(row_to_json(s))) <span style=font-weight:700>FROM</span> s;
</code></pre></div><p>然后把结果插入到请求的数据中去：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>res[0][<span style=font-style:italic>&#34;pre_title&#34;</span>] = navi[0][0].get(<span style=font-style:italic>&#39;title&#39;</span>) <span style=font-weight:700>if</span> id &gt; 1 <span style=font-weight:700>else</span> <span style=font-weight:700>None</span>
res[0][<span style=font-style:italic>&#34;next_title&#34;</span>] = navi[0][-1].get(<span style=font-style:italic>&#39;title&#39;</span>) <span style=font-weight:700>if</span> id &lt; MAXID <span style=font-weight:700>else</span> <span style=font-weight:700>None</span>
</code></pre></div><p>其中<code>res</code>是第一次查询的结果，<code>navi</code>是第二次查询的结果。这样就显式的声明了前后文的标题，也就不会出现顺序的错误了，而且大大减少了传输的数据。</p>
<h2 id=前端实现>
前端实现
<a class=heading-link href=#%e5%89%8d%e7%ab%af%e5%ae%9e%e7%8e%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>目前只实现了原文的展示功能，整个页面分为如下几个部分：</p>
<pre><code>1. 顶部导航条，导航条目前有两个部分：左上角的Brand和右上角的随机浏览按钮。之后左上角还想加上搜索框。
2. 上下翻页栏。
3. 目录结构显示，这个功能实现了，但是不知道放在哪里比较好看，所以被我注释掉了。
4. 标题和正文。
</code></pre>
<h3 id=顶部导航条>
顶部导航条
<a class=heading-link href=#%e9%a1%b6%e9%83%a8%e5%af%bc%e8%88%aa%e6%9d%a1>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<p>html代码如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>	&lt;<span style=font-weight:700>nav</span> class=<span style=font-style:italic>&#34;navbar navbar-default navbar-fixed-top&#34;</span>&gt;
        &lt;<span style=font-weight:700>div</span> class=<span style=font-style:italic>&#34;container&#34;</span>&gt;
            &lt;<span style=font-weight:700>a</span> class=<span style=font-style:italic>&#34;navbar-brand&#34;</span> href=<span style=font-style:italic>&#34;#&#34;</span>&gt;&lt;<span style=font-weight:700>img</span> id=<span style=font-style:italic>&#34;brand&#34;</span> src=<span style=font-style:italic>&#34;favicon.png&#34;</span>&gt;&lt;/<span style=font-weight:700>a</span>&gt; 
            &lt;<span style=font-weight:700>ul</span> class=<span style=font-style:italic>&#34;nav navbar-nav navbar-right&#34;</span>&gt;
                &lt;<span style=font-weight:700>li</span>&gt;
                    &lt;<span style=font-weight:700>a</span> id=<span style=font-style:italic>&#34;random_ode&#34;</span> href=<span style=font-style:italic>&#34;#&#34;</span> class=<span style=font-style:italic>&#34;btn-lg&#34;</span>&gt;
                        &lt;<span style=font-weight:700>span</span> class=<span style=font-style:italic>&#34;glyphicon glyphicon-random&#34;</span> aria-hidden=<span style=font-style:italic>&#34;true&#34;</span>&gt;&lt;/<span style=font-weight:700>span</span>&gt;
                    &lt;/<span style=font-weight:700>a</span>&gt;
                &lt;/<span style=font-weight:700>li</span>&gt;
            &lt;/<span style=font-weight:700>ul</span>&gt;
        &lt;/<span style=font-weight:700>div</span>&gt;
    &lt;/<span style=font-weight:700>nav</span>&gt;
</code></pre></div><p>就是bootstrap的默认组件而已，稍微值得一提的是随机数的产生：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=font-weight:700>function</span> getRandomInt(x) {
  <span style=font-weight:700>return</span> Math.floor(Math.random() * x) + 1;
}
</code></pre></div><p>应该是可以产生1到x之间的任意整数的，包括x。</p>
<h3 id=上下翻页>
上下翻页
<a class=heading-link href=#%e4%b8%8a%e4%b8%8b%e7%bf%bb%e9%a1%b5>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<p>就是两个简单的超链接，一个推到左上角，一个推到右上角。左右的篇章id通过api请求得到，这个之前已经提到过。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>	&lt;<span style=font-weight:700>div</span> id=<span style=font-style:italic>&#34;navigate&#34;</span>&gt;
        &lt;<span style=font-weight:700>span</span> class=<span style=font-style:italic>&#39;pull-left&#39;</span>&gt;
            &lt;<span style=font-weight:700>a</span> id=<span style=font-style:italic>&#34;left_ode&#34;</span> class=<span style=font-style:italic>&#34;navigate&#34;</span>&gt;
            &lt;/<span style=font-weight:700>a</span>&gt;
        &lt;/<span style=font-weight:700>span</span>&gt;
        &lt;<span style=font-weight:700>span</span> class=<span style=font-style:italic>&#34;pull-right&#34;</span>&gt;
            &lt;<span style=font-weight:700>a</span> id=<span style=font-style:italic>&#34;right_ode&#34;</span> class=<span style=font-style:italic>&#34;navigate&#34;</span>&gt;
            &lt;/<span style=font-weight:700>a</span>&gt;
        &lt;/<span style=font-weight:700>span</span>&gt;
    &lt;/<span style=font-weight:700>div</span>&gt;
</code></pre></div><h3 id=正文部分>
正文部分
<a class=heading-link href=#%e6%ad%a3%e6%96%87%e9%83%a8%e5%88%86>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<p>正文部分分为标题和内容两个部分，值得一提的<code>css</code>部分。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>	&lt;<span style=font-weight:700>div</span> id=<span style=font-style:italic>&#34;ode&#34;</span>&gt;
        &lt;<span style=font-weight:700>div</span> id=<span style=font-style:italic>&#34;title&#34;</span>&gt;&lt;/<span style=font-weight:700>div</span>&gt;     
        &lt;<span style=font-weight:700>div</span> id=<span style=font-style:italic>&#34;fulltext&#34;</span>&gt;&lt;/<span style=font-weight:700>div</span>&gt;
    &lt;/<span style=font-weight:700>div</span>&gt;
</code></pre></div><p>由于我觉得诗经这种长短参差不齐的诗句，全部左对齐会好看一些，但是又希望标题能够居中，并且和正文对齐。所以需要它的宽度和内容自适应。解决方法是将它设置为<code>inline-block</code>。
另外，在上传时，内容中就包含了换行符，以此来保证诗文显示出来的格式正确(为了限制长度，手工调整过一次，不过调整得非常不仔细，所以可能会出现内容连贯，但是被我强行换行的情况。)，所以需要能够自动显示出换行符。解决方法是<code>pre</code>。
于是，完整的css设置如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css>#<span style=font-weight:700>ode</span>{
	<span style=font-weight:700>text-align</span>: <span style=font-weight:700>center</span>;
	<span style=font-weight:700>font-family</span>: Helvetica, Tahoma, Arial, STXihei, <span style=font-style:italic>&#34;华文细黑&#34;</span>, <span style=font-style:italic>&#34;Microsoft YaHei&#34;</span>, <span style=font-style:italic>&#34;微软雅黑&#34;</span>, SimSun, <span style=font-style:italic>&#34;宋体&#34;</span>, Heiti, <span style=font-style:italic>&#34;黑体&#34;</span>, <span style=font-weight:700>sans-serif</span>;
}

#<span style=font-weight:700>title</span>{
	<span style=font-weight:700>font-size</span>: 3.5<span>em</span>;
	<span style=font-weight:700>margin</span>: 5<span>%</span> <span style=font-weight:700>auto</span>;
}

#<span style=font-weight:700>fulltext</span>{
	<span style=font-weight:700>font-size</span>: 2.5<span>em</span>;
	<span style=font-weight:700>margin</span>: <span style=font-weight:700>auto</span>;
	<span style=font-weight:700>text-align</span>: <span style=font-weight:700>left</span>;
	<span style=font-weight:700>white-space</span>:<span style=font-weight:700>pre</span>;
	<span style=font-weight:700>display</span>:<span style=font-weight:700>inline-block</span>; 
	<span>*</span><span style=font-weight:700>display</span>:<span style=font-weight:700>inline</span>; 
	<span>*</span>zoom:1; 
}
</code></pre></div><h2 id=部分javascript功能代码>
部分JavaScript功能代码
<a class=heading-link href=#%e9%83%a8%e5%88%86javascript%e5%8a%9f%e8%83%bd%e4%bb%a3%e7%a0%81>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<h3 id=获取页面参数>
获取页面参数
<a class=heading-link href=#%e8%8e%b7%e5%8f%96%e9%a1%b5%e9%9d%a2%e5%8f%82%e6%95%b0>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<p>由于浏览器得到的只是一个html文件，所以它得不到请求的参数，需要从<code>url</code>手工解析出来。解析的<code>javascript</code>代码如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=font-weight:700>var</span> getUrlParameter = <span style=font-weight:700>function</span> getUrlParameter(sParam) {
    <span style=font-weight:700>var</span> sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split(<span style=font-style:italic>&#39;&amp;&#39;</span>),
        sParameterName,
        i;

    <span style=font-weight:700>for</span> (i = 0; i &lt; sURLVariables.length; i++) {
        sParameterName = sURLVariables[i].split(<span style=font-style:italic>&#39;=&#39;</span>);

        <span style=font-weight:700>if</span> (sParameterName[0] === sParam) {
            <span style=font-weight:700>return</span> sParameterName[1] === <span style=font-weight:700>undefined</span> ? <span style=font-weight:700>true</span> : sParameterName[1];
        }
    }
};

page_id = getUrlParameter(<span style=font-style:italic>&#39;id&#39;</span>);
<span style=font-weight:700>if</span> (!page_id) {
	page_id = 1;
}
</code></pre></div><p>下面的一小段代码是如果没有解析到参数，默认显示第一篇，这样就可以通过最简单的域名访问到网站了：<a href=http://odes.mkdef.com>odes.mkdef.com</a></p>
<h3 id=字符串替换>
字符串替换
<a class=heading-link href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%9b%bf%e6%8d%a2>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<p>由于<code>lodash</code>使用的时候需要一些额外的工作，为了简单抄了一段实现字符串替换功能的代码，效果不错。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>String.prototype.replaceAll = <span style=font-weight:700>function</span>(search, replacement) {
    <span style=font-weight:700>var</span> target = <span style=font-weight:700>this</span>;
    <span style=font-weight:700>return</span> target.replace(<span style=font-weight:700>new</span> RegExp(search, <span style=font-style:italic>&#39;g&#39;</span>), replacement);
};
</code></pre></div><h2 id=小结>
小结
<a class=heading-link href=#%e5%b0%8f%e7%bb%93>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>我写前端的经验真的非常匮乏，所以这些实现仅仅保证了看起来是设想的那样子，至于是不是最优，会不会有其他潜在的缺点就不得而知了，至少目前还没有暴露出来。这篇文章仅仅当作给自己的一份前端笔记好了。</p>
</div>
<footer>
</footer>
</article>
</section>
</div>
<footer class=footer>
<section class=container>
©
2016 -
2022
无生
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.
</section>
</footer>
</main>
<script src=/js/coder.min.39a51230dce2ac866c049b52573e38bf60666af4bc63c1bdf203b9b2d95b1cd6.js integrity="sha256-OaUSMNzirIZsBJtSVz44v2BmavS8Y8G98gO5stlbHNY="></script>
</body>
</html>