<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=author content="无生"><meta name=description content="结果    目前的代码能通过可以被认为是作弊的方法得到hard模式下的最优解： 初始词 salet, 一共猜测8116次，最多的单词猜7次。
如果需要证明这是最优的，需要遍历所有的单词，枚举所有的可能步骤。这需要大量的时间。不过能力有限，我打算就到此为止了，本文会简单的记录我所发现和使用的一些优化方法。
起点    前文已经给出了目标解的形式，一棵决策树，节点是猜测的单词，状态是转移条件。同时，这棵树是具有最优子结构的。
best[guess] = min(sum(best[next_guess], pattern for next_guess)) for next_guess in all available guesses 从形式上来说，具备树形dp的一切条件。不过这并没有太多改善，因为每一步的状态转移可能性仍然有12000种，而我们也看到最优解最深需要猜7次。这个复杂度是不能接受的。
用整数表示状态    其实这个优化我在很晚才做，虽然这个优化是显然的，不管时间还是空间上，都会得到很大的改善。
但是它会导致状态丧失直观性，我几乎没有办法用肉眼检查计算是否正确。不过多亏了Rust严格的编译期检查，我在后期还算简单地完成了这个修改。
pub fn check(target: &str, guess: &str) -> u8 {  let mut freq = BTreeMap::<char, usize>::new();  for (guess_c, target_c) in guess.chars().zip(target.chars()) {  if guess_c != target_c {  let counter = freq.entry(target_c).or_insert(0);  *counter += 1;  }  }   let mut pattern: u8 = 0;  let mut base: u8 = 1;  for (guess_c, target_c) in guess."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Wordle优化"><meta name=twitter:description content="结果    目前的代码能通过可以被认为是作弊的方法得到hard模式下的最优解： 初始词 salet, 一共猜测8116次，最多的单词猜7次。
如果需要证明这是最优的，需要遍历所有的单词，枚举所有的可能步骤。这需要大量的时间。不过能力有限，我打算就到此为止了，本文会简单的记录我所发现和使用的一些优化方法。
起点    前文已经给出了目标解的形式，一棵决策树，节点是猜测的单词，状态是转移条件。同时，这棵树是具有最优子结构的。
best[guess] = min(sum(best[next_guess], pattern for next_guess)) for next_guess in all available guesses 从形式上来说，具备树形dp的一切条件。不过这并没有太多改善，因为每一步的状态转移可能性仍然有12000种，而我们也看到最优解最深需要猜7次。这个复杂度是不能接受的。
用整数表示状态    其实这个优化我在很晚才做，虽然这个优化是显然的，不管时间还是空间上，都会得到很大的改善。
但是它会导致状态丧失直观性，我几乎没有办法用肉眼检查计算是否正确。不过多亏了Rust严格的编译期检查，我在后期还算简单地完成了这个修改。
pub fn check(target: &str, guess: &str) -> u8 {  let mut freq = BTreeMap::<char, usize>::new();  for (guess_c, target_c) in guess.chars().zip(target.chars()) {  if guess_c != target_c {  let counter = freq.entry(target_c).or_insert(0);  *counter += 1;  }  }   let mut pattern: u8 = 0;  let mut base: u8 = 1;  for (guess_c, target_c) in guess."><meta property="og:title" content="Wordle优化"><meta property="og:description" content="结果    目前的代码能通过可以被认为是作弊的方法得到hard模式下的最优解： 初始词 salet, 一共猜测8116次，最多的单词猜7次。
如果需要证明这是最优的，需要遍历所有的单词，枚举所有的可能步骤。这需要大量的时间。不过能力有限，我打算就到此为止了，本文会简单的记录我所发现和使用的一些优化方法。
起点    前文已经给出了目标解的形式，一棵决策树，节点是猜测的单词，状态是转移条件。同时，这棵树是具有最优子结构的。
best[guess] = min(sum(best[next_guess], pattern for next_guess)) for next_guess in all available guesses 从形式上来说，具备树形dp的一切条件。不过这并没有太多改善，因为每一步的状态转移可能性仍然有12000种，而我们也看到最优解最深需要猜7次。这个复杂度是不能接受的。
用整数表示状态    其实这个优化我在很晚才做，虽然这个优化是显然的，不管时间还是空间上，都会得到很大的改善。
但是它会导致状态丧失直观性，我几乎没有办法用肉眼检查计算是否正确。不过多亏了Rust严格的编译期检查，我在后期还算简单地完成了这个修改。
pub fn check(target: &str, guess: &str) -> u8 {  let mut freq = BTreeMap::<char, usize>::new();  for (guess_c, target_c) in guess.chars().zip(target.chars()) {  if guess_c != target_c {  let counter = freq.entry(target_c).or_insert(0);  *counter += 1;  }  }   let mut pattern: u8 = 0;  let mut base: u8 = 1;  for (guess_c, target_c) in guess."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.mkdef.com/posts/wordle%E4%BC%98%E5%8C%96/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-31T11:49:28+08:00"><meta property="article:modified_time" content="2022-03-31T11:49:28+08:00"><title>Wordle优化 · Coder</title><link rel=canonical href=https://blog.mkdef.com/posts/wordle%E4%BC%98%E5%8C%96/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.97.3"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Coder</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://blog.mkdef.com/posts/wordle%E4%BC%98%E5%8C%96/>Wordle优化</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-03-31T11:49:28+08:00>March 31, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
3-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/rust/>Rust</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/wordle/>Wordle</a></span></div></div></header><div><h3 id=结果>结果
<a class=heading-link href=#%e7%bb%93%e6%9e%9c><i class="fa fa-link" aria-hidden=true></i></a></h3><p>目前的代码能通过可以被认为是作弊的方法得到hard模式下的最优解：
初始词 salet, 一共猜测8116次，最多的单词猜7次。</p><p>如果需要证明这是最优的，需要遍历所有的单词，枚举所有的可能步骤。这需要大量的时间。不过能力有限，我打算就到此为止了，本文会简单的记录我所发现和使用的一些优化方法。</p><h3 id=起点>起点
<a class=heading-link href=#%e8%b5%b7%e7%82%b9><i class="fa fa-link" aria-hidden=true></i></a></h3><p>前文已经给出了目标解的形式，一棵决策树，节点是猜测的单词，状态是转移条件。同时，这棵树是具有最优子结构的。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>best[guess] = min(sum(best[next_guess], pattern for next_guess)) for next_guess in all available guesses
</span></span></code></pre></div><p>从形式上来说，具备树形dp的一切条件。不过这并没有太多改善，因为每一步的状态转移可能性仍然有12000种，而我们也看到最优解最深需要猜7次。这个复杂度是不能接受的。</p><h3 id=用整数表示状态>用整数表示状态
<a class=heading-link href=#%e7%94%a8%e6%95%b4%e6%95%b0%e8%a1%a8%e7%a4%ba%e7%8a%b6%e6%80%81><i class="fa fa-link" aria-hidden=true></i></a></h3><p>其实这个优化我在很晚才做，虽然这个优化是显然的，不管时间还是空间上，都会得到很大的改善。</p><p>但是它会导致状态丧失直观性，我几乎没有办法用肉眼检查计算是否正确。不过多亏了Rust严格的编译期检查，我在后期还算简单地完成了这个修改。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> check(target: <span>&amp;</span><span>str</span>, guess: <span>&amp;</span><span>str</span>) -&gt; <span>u8</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> freq = BTreeMap::&lt;<span>char</span>, <span>usize</span>&gt;::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> (guess_c, target_c) <span style=font-weight:700>in</span> guess.chars().zip(target.chars()) {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> guess_c != target_c {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> counter = freq.entry(target_c).or_insert(0);
</span></span><span style=display:flex><span>                *counter += 1;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> pattern: <span>u8</span> = 0;
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> base: <span>u8</span> = 1;
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> (guess_c, target_c) <span style=font-weight:700>in</span> guess.chars().zip(target.chars()) {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> guess_c == target_c {
</span></span><span style=display:flex><span>                pattern += 2 * base;
</span></span><span style=display:flex><span>            } <span style=font-weight:700>else</span> {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> counter = freq.entry(guess_c).or_insert(0);
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> *counter &gt; 0 {
</span></span><span style=display:flex><span>                    pattern += base;
</span></span><span style=display:flex><span>                    *counter -= 1;
</span></span><span style=display:flex><span>                } 
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            base *= 3;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pattern
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=初步剪枝>初步剪枝
<a class=heading-link href=#%e5%88%9d%e6%ad%a5%e5%89%aa%e6%9e%9d><i class="fa fa-link" aria-hidden=true></i></a></h3><p>首先，由于上文大坑的原因，每回合我们需要考虑的guess范围是所有可行解，而不只是可能解。这就导致很多guesses可能对这回合毫无帮助，例如总是猜同一个单词。这会导致无限循环。所以一个很简单的条件就是检查这个guess能把当前所有可能的解分成多少个pattern，如果猜完还是一个group，而且这个group不是GGGGG，那么这个猜测就是毫无意义的，我们可以直接忽略。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span> <span style=font-weight:700>if</span> groups.len() == 1 &amp;&amp; !groups.contains_key(242) {
</span></span><span style=display:flex><span>            <span style=font-weight:700>continue</span>
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>对于每一个guess，我们需要依次检查所有pattern, 但是可能检查到中间某一个pattern的时候，就发现它的猜测次数就已经超过当前找到的可行解。那么这个guess的剩下的pattern就不用继续检查了。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>if</span> current_guess.total_count &gt; best_of_all_guess.total_count {
</span></span><span style=display:flex><span>    current_guess.has_result = <span style=font-weight:700>false</span>;
</span></span><span style=display:flex><span>    <span style=font-weight:700>break</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个检查还能不能继续改进呢？</p><p>想要这个不等式成立，我们可以分别考虑增加左边和减少右边。</p><p>我们先考虑减少右边，右边最小值也就是最优值了。意味着我们需要尽可能早的检查最有可能是最优解的guess，那么这里就可以用到前文提到的启发式策略了。我们先检查期望信息量最大的guess:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> get_entropy_sum&lt;&#39;a&gt;(guess: <span>&amp;</span>&#39;a <span>str</span>, answers: <span>&amp;</span><span style=font-weight:700>BTreeSet</span>&lt;&amp;&#39;a <span>str</span>&gt;) -&gt; (&amp;&#39;a <span>str</span>, <span>u32</span>, BTreeMap&lt;<span>u8</span>, BTreeSet&lt;&amp;&#39;a <span>str</span>&gt;&gt;) {
</span></span><span style=display:flex><span>    <span style=font-weight:700>let</span> groups = group_by_pattern(guess, answers);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>let</span> entropy = groups.iter().map(|(pattern, group)| {
</span></span><span style=display:flex><span>        get_entropy(*pattern, group.len() <span style=font-weight:700>as</span> <span>u32</span>)
</span></span><span style=display:flex><span>    }).sum();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (guess, entropy, groups)
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>然后在枚举guess前，按照entropy排序，优先检查期望信息量最大的guess即可。</p><p>那么左边能否增加呢？左边是当前guess已经检查过的pattern需要的猜测次数之和，我们有没有可能预判一下剩下的pattern需要多少猜测次数呢？需要注意的是，这个预判的次数只能比真实的次数少，而不能多。</p><p>我在第一次预估这个次数时，考虑的是，对于一个比如长度为4的group，每回合我的猜测都能对半分，那么log2次就能猜出单词，所以总次数就是4 * log2(4)得到8次。即使不考虑第一次可能就猜对，导致总和可能只需要7次。最大的问题其实在于，这里最好情况并不只是2分，这里每一个guess可能的pattern有243种(当然，这里面有一些不可能出现的pattern, 比如GGGGY)！所以对于长度不超过243的group来说，最好情况可能是1次猜测就能他们全都分好组，最后再猜一次即可。这里应该是log243而不是log2。</p><p>当然，group大于243的情况并不是很常见。我们可以简单的用 2 * length - 1 的公式来估计这个最理想情况。一次猜测区分所有结果并且命中其中一个，然后其他结果的情况就最多再猜一次。</p><p>有了这个预估，我们可以做到两个优化：</p><ol><li>在检查具体的pattern前，我们就能计算得到这个guess的最理想情况：
sum(2*group.len() - 1) for all groups.</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>if</span> current_guess.total_count + lower_bound &gt; best_of_all_guess.total_count {
</span></span><span style=display:flex><span>        <span style=font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ol start=2><li>在中间某一步，我们可以把当前的pattern的预估用已经检查完成过的最优值替换，然后再来比较：</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-style:italic>// 更新当前guess的猜测此时
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    current_guess.update(pattern, sub_result);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 计算出当前guess的预估值
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    <span style=font-weight:700>let</span> current_entropy = get_entropy(pattern, pattern_answers.len() <span style=font-weight:700>as</span> <span>u32</span>);
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 从第一步计算得到的lower_bound减去当前group的预估值，相当于用真实值代替掉预估值
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    lower_bound -= current_entropy;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 最后再来做比较
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    <span style=font-weight:700>if</span> current_guess.total_count  + lower_bound &gt; best_of_all_guess.total_count {
</span></span><span style=display:flex><span>        current_guess.has_result = <span style=font-weight:700>false</span>;
</span></span><span style=display:flex><span>        <span style=font-weight:700>break</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=猜测范围的小优化>猜测范围的小优化
<a class=heading-link href=#%e7%8c%9c%e6%b5%8b%e8%8c%83%e5%9b%b4%e7%9a%84%e5%b0%8f%e4%bc%98%e5%8c%96><i class="fa fa-link" aria-hidden=true></i></a></h3><p>在分析刚才的优化过程中，我发现了另外一个小的优化点。</p><ol><li><p>如果猜测只剩下两个值了，无论我猜哪一个，都只剩下一个解，我们随便猜一个都是最优解。这个时候就不用去检查每一个可能值了。</p></li><li><p>如果猜测范围还剩下三个值，如果我猜三个可能值之外的值，最好情况也就是三分，然后各猜一次，一共6次。那我不如直接猜这个三个值，最坏情况也就是最后才猜到，总的猜测次数还是1+2+3=6次。</p></li></ol><p>综上，当可能解的个数为2~3时，可以只考虑可行解，而不用去遍历全集。这个优化虽然小但非常有效，因为在搜索树的末端，大部分都是这种小的group。</p><h3 id=确定初始词>确定初始词
<a class=heading-link href=#%e7%a1%ae%e5%ae%9a%e5%88%9d%e5%a7%8b%e8%af%8d><i class="fa fa-link" aria-hidden=true></i></a></h3><p>其实对于每一步可以猜测的词来说，词与词之间的运算是完全独立的。所以我们可以先固定某个搜索词进行探索，然后针对不同的搜索词进行相同的计算即可。</p><p>初始词的选择也是按照启发式的顺序排序的，在3b1b的补充视频里有提到这个过程。但是这个过程不必很严谨，因为最后都是要遍历所有初始词的。</p><p>我这里直接取leaderboard上的最优词，salet。</p><h3 id=限制搜索深度>限制搜索深度
<a class=heading-link href=#%e9%99%90%e5%88%b6%e6%90%9c%e7%b4%a2%e6%b7%b1%e5%ba%a6><i class="fa fa-link" aria-hidden=true></i></a></h3><p>显然，最优解的深度不会太深，但是很难证明这一点。我们可以通过慢慢放宽这个限制，从5次无解，到6次有解，到7次可能是最优解。但是无法证明8次，9次或者更多次的解不会更优。</p><p>如果我们需要证明解是最优的，我个人理解是不能有这个条件的。但是不妨碍我们在已知最优解深度的情况下，通过限制这个深度来得到最优解。</p><p>我的代码里设置的常数是5，但是得到的解可以为7。因为深度5，可行解还剩一个的时候，我是直接返回的一个解法，而没有做限制，加上当前这一层，所以最大深度可以到7。</p><h3 id=去重>去重
<a class=heading-link href=#%e5%8e%bb%e9%87%8d><i class="fa fa-link" aria-hidden=true></i></a></h3><p>有一些猜测词猜完之后，会导致结果分组情况完全一致（极端一点就是他们都完全没用。）。这时我们能根据group的情况来去重。可以有效减少重复计算的运算量。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-style:italic>// 去重的集合，key就是分组情况
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> group_patterns = BTreeSet::&lt;BTreeMap&lt;<span>u8</span>, BTreeSet&lt;&amp;<span>str</span>&gt;&gt;&gt;::new();
</span></span><span style=display:flex><span>    <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> preprocess_by_guess:Vec&lt;_&gt; = availables
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .filter_map(|guess| {
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> (guess, entropy, groups) = get_entropy_sum(guess, &amp;answers);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-style:italic>// 如果这个组合已经出现过，就不再重复计算了。
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-weight:700>if</span> group_patterns.contains(&amp;groups) {
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> None
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>            group_patterns.insert(groups.clone());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> Some((guess, entropy, groups))
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .collect();
</span></span></code></pre></div><h3 id=group排序>group排序
<a class=heading-link href=#group%e6%8e%92%e5%ba%8f><i class="fa fa-link" aria-hidden=true></i></a></h3><p>对于一个待检查的guess，我们对于所有的pattern是从小到大来还是从大到小来呢？</p><p>理论上，这里配合上文预估total_count的优化，最好是能尽快达到best of guess的total count，这样就能尽早退出循环。</p><p>从小到大，计算快但是增长慢。 从大到小增长快，但是计算慢。试验下来，从小到大会快很多。原因不明。</p><h3 id=一些看上去没有什么效果的优化>一些看上去没有什么效果的优化
<a class=heading-link href=#%e4%b8%80%e4%ba%9b%e7%9c%8b%e4%b8%8a%e5%8e%bb%e6%b2%a1%e6%9c%89%e4%bb%80%e4%b9%88%e6%95%88%e6%9e%9c%e7%9a%84%e4%bc%98%e5%8c%96><i class="fa fa-link" aria-hidden=true></i></a></h3><h4 id=预估深度>预估深度
<a class=heading-link href=#%e9%a2%84%e4%bc%b0%e6%b7%b1%e5%ba%a6><i class="fa fa-link" aria-hidden=true></i></a></h4><p>和前面预估计算量类似，我们可以预估深度。方法也很简单：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> get_lower_bound_level(length: <span>usize</span>) -&gt; <span>u8</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>match</span> length {
</span></span><span style=display:flex><span>        1 =&gt; 1,
</span></span><span style=display:flex><span>        2..=243 =&gt; 2,
</span></span><span style=display:flex><span>        _ =&gt; 3
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>原理和之前类似，最理想情况就是243分。那么长度为1就是1次，其他都是2次。大于243的group很少，我们可以统一归为3次。</p><p>然后检查如果当前深度加上最少的深度大于上文中限制的最大深度，提前退出。但是好像这个条件不太会触发，所以最后也没有加上。</p><h4 id=并发>并发
<a class=heading-link href=#%e5%b9%b6%e5%8f%91><i class="fa fa-link" aria-hidden=true></i></a></h4><p>前面提到，由于词与词之间的运算是完全独立的。我们完全可以并发的来计算不同的词。</p><p>但是，我们不能在每一层的计算都完全并行，完全并行之后，上面的优化就全都无效了。这样我们就只能靠计算能力来应付所有的可能性。这样是得不偿失的。</p><p>其次，如果只在第一层并行，这里的瓶颈其实在于最大的一个group，其他的线程其实很快就能计算完成，然后一起围观这个最大的group。</p><p>那么如果把task继续细化呢，把前两层的所有可能性拿出来，然后并发是不是可以把任务分的更均匀呢？这里去重前的任务大概有80w：</p><ol><li><p>如果每一种情况，都提前计算剩余的可行解和可行的猜测集合，需要大量的内存，而且不管是插入还是查询都非常慢。</p></li><li><p>如果只划分任务，线程自己单独计算可行解和可行的猜测，这里有大量重复的计算，时间上效果也并不好。</p></li></ol><p>综上，这个优化的效果非常有限。</p><h4 id=记忆化>记忆化
<a class=heading-link href=#%e8%ae%b0%e5%bf%86%e5%8c%96><i class="fa fa-link" aria-hidden=true></i></a></h4><p>最后来介绍cache，其实这个优化很容易想到，但是做了很多次效果都很一般，即使参考了其他人对cache更进一步的利用之后，效果还是非常不明显。所以最后也没有用上。</p><p>首先，我们需要定义状态，判断当前状态是否出现过，其实有很多条件。最简单的一些有：</p><ol><li>当前的可行解范围</li><li>猜测范围，通过不同路径得到相同的可行解范围，可猜测范围不一定相同，所以这也得是状态的一部分。</li></ol><p>如果采用了上文中提到的搜索深度限制，我们还需要考虑剩余的搜索次数，如果之前到这个状态，剩余搜索次数是2次，而当前有三次，那显然，前面得到的不一定是最优解。</p><p>所以只有剩余搜索次数完全相同的情况下，才能直接返回前面计算的结果。</p><p>更深一层，如果当前剩余猜测次数是3次：</p><ol><li>前面有剩余4次的记录，而且结果是无解，我们可以直接返回无解。</li><li>如果有剩余2次的记录，而且有解，虽然他可能不是最优解。但我们可以拿来作为当前最优解。</li></ol><p>不过实现后发现，无解的记录一次都不会被利用到。</p><p>以下是相关代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-style:italic>// 定义
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>type</span> <span style=font-weight:700>Cache</span>&lt;&#39;a&gt; = BTreeMap&lt;Restriction, BTreeMap&lt;BTreeSet&lt;&amp;&#39;a <span>str</span>&gt;, BTreeMap&lt;<span>u8</span>, Best&lt;&#39;a&gt;&gt;&gt;&gt;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>// 存
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    cache  
</span></span><span style=display:flex><span>        .lock()
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>        .entry(restrictions)
</span></span><span style=display:flex><span>        .or_insert_with(BTreeMap::new)
</span></span><span style=display:flex><span>        .entry(availables.to_owned())
</span></span><span style=display:flex><span>        .or_insert_with(BTreeMap::new)
</span></span><span style=display:flex><span>        .insert(current, best_of_all_guess.clone());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>// 取
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> best_of_all_guess = Best::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> <span style=font-weight:700>let</span> Some(restrictions_cache) = cache.lock().unwrap().get(&amp;restrictions) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> <span style=font-weight:700>let</span> Some(answers_cache) = restrictions_cache.get(answers) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-style:italic>// 有记录的最优解:
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-weight:700>if</span> <span style=font-weight:700>let</span> Some(level_cache) = answers_cache.get(&amp;current) {
</span></span><span style=display:flex><span>                counter.result_counter += 1;
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> level_cache.clone();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-style:italic>// 有记录的无解:
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-style:italic>// for level in 0..(current - 1) {
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-style:italic>//     if let Some(level_cache) = answers_cache.get(&amp;level) {
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-style:italic>//         if !level_cache.has_result || level_cache.max_level + current &lt;= MAX_TURNS {
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-style:italic>//             counter.no_result_counter += 1;
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-style:italic>//             return level_cache.clone()
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-style:italic>//         }
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-style:italic>//     }
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-style:italic>// }
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            
</span></span><span style=display:flex><span>            <span style=font-style:italic>// 有记录的解作为当前最优解:
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-weight:700>for</span> level <span style=font-weight:700>in</span> (current + 1) .. MAX_TURNS {
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> <span style=font-weight:700>let</span> Some(level_cache) = answers_cache.get(&amp;level) {
</span></span><span style=display:flex><span>                    counter.baseline_counter += 1;
</span></span><span style=display:flex><span>                    best_of_all_guess = level_cache.clone();
</span></span><span style=display:flex><span>                    <span style=font-weight:700>break</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>这里稍微记录一下Rust相关的知识点，由于cache需要被全局访问并更新，并发的情况下还要线程安全。在Rust里需要被包裹两次：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-style:italic>// 真正的cache需要定义成这样
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    <span style=font-weight:700>let</span> cache = Arc::new(Mutex::new(Cache::new()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 访问的时候需要先lock再unwrap
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    cache  
</span></span><span style=display:flex><span>        .lock()
</span></span><span style=display:flex><span>        .unwrap()
</span></span></code></pre></div><h4 id=状态压缩>状态压缩
<a class=heading-link href=#%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9><i class="fa fa-link" aria-hidden=true></i></a></h4><p>这里其实是承接上面cache的，可以想象cache需要的内存非常之大。那么状态可不可以压缩呢？</p><p>其实，一串可行解和另一串可行解之间可能是同构的。我们以数字来举例：</p><p>比如a状态的可行解有以下三种： 111,112,113</p><p>b状态的可行解有以下三种： 444,445,446</p><p>可以看出，他们本质上是相同的状态，通过a状态的决策树也能很容易的得到b状态的决策树。</p><p>但是，我们很难判断两个状态是否是同构的。</p><p>另外，在wordle这个游戏里，可行解都必须是单词，想让两组单词同构，可想而知是不容易的。</p><h3 id=作弊>作弊
<a class=heading-link href=#%e4%bd%9c%e5%bc%8a><i class="fa fa-link" aria-hidden=true></i></a></h3><p>其实上面限制深度已经是类似作弊的手段了，但至少可以得到一个在限制深度的情况下最优解。接下来要提到的优化则可能得不到最优解。</p><p>到目前为止，用上上述所有的方法，我也只能在合理时间(1min)里算出1400个单词的最优解。如果放开到全部2300个单词，没有尝试。</p><p>无奈之下，我尝试了这个剪枝方法：对于每个回合，我只猜测最有可能的几个guess，后面的直接不看了。</p><p>我把这个阈值限制在13的时候，可以计算出榜上的最优解。</p><p>显然这个结论几乎没有意义，只能给我们得出一个看上去很不错的解。但是不能证明它在任何情况下是最优的。加上这个剪枝后，可以在13s左右得到salet在hard模式下的最优解:8116。</p></div><footer></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2016 -
2022
无生
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.8fb86376a16e684af472a329aef502dbebcfab65ce264e9750d144912947c602.js integrity="sha256-j7hjdqFuaEr0cqMprvUC2+vPq2XOJk6XUNFEkSlHxgI="></script></body></html>