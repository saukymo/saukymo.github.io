<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=author content="无生"><meta name=description content="参考文档     Kubernetes权威指南 How to Add Users to Kubernetes (kubectl)? Kubernetes Documentation  实现思路    Kubernetes集群主要由Master节点控制，Master节点又主要由其中的API Sever(kube-apiserver)提供Rest接口服务。所以我们大体思路就是在CI中配置好正确的kubectl客户端，使它能够直接连到部署的集群上，从而实现远程部署。
目前CI主要分为test, build, deploy等几个阶段，在build阶段就把新的image打包好并且上传到私有registry了，那么deploy阶段就只需要告诉kubernetes新的image编号，kubernetes就会自动帮我们下载新的镜像并且重新部署。
由于目前deploy阶段采用的runner是shell runner，使用的用户是gitlab-runner。可以理解为使用gitlab-runner用户登录到git.hupofin.tech这台机器上去，然后执行ci阶段里定义的命令。
所以我们需要给gitlab-runner配置一个kubectl客户端，这样一来，所有使用shell runner来执行ci的阶段都可以访问集群了
手动完成首次部署    首次部署应用到kubernetes不是本次的重点，可以参考kubernetes官网的交互式tutorial，很清晰。
Service Account    既然是在集群外远程访问控制集群，那么就需要一定的身份认证机制。这里采用Service Account的方式进行验证。
Service Account包括三个部分： namespace，token和CA证书。
所以我们需要做的就是在集群中创建一个新的sa用于部署，然后将上面三样东西配置在kubectl客户端就可以了。
创建一个新的SA    	kubectl create sa shaobo 获得secret的名字    	kubectl get sa shaobo -o json | jq -r .secrets[].name 	- shaobo-token-rq201 一个Service Account可以包含多个secret，例如刚刚我们创建一个新的SA时自动生成的secret就是用于访问API的secret。 同时，我们也可以自己定义其他的secret，例如在从私有registry下载镜像时可能会需要一个下载镜像的secret，使用https时需要相关证书的secret等等。"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="在Gitlab-CI中设置kubectl实现自动部署"><meta name=twitter:description content="参考文档     Kubernetes权威指南 How to Add Users to Kubernetes (kubectl)? Kubernetes Documentation  实现思路    Kubernetes集群主要由Master节点控制，Master节点又主要由其中的API Sever(kube-apiserver)提供Rest接口服务。所以我们大体思路就是在CI中配置好正确的kubectl客户端，使它能够直接连到部署的集群上，从而实现远程部署。
目前CI主要分为test, build, deploy等几个阶段，在build阶段就把新的image打包好并且上传到私有registry了，那么deploy阶段就只需要告诉kubernetes新的image编号，kubernetes就会自动帮我们下载新的镜像并且重新部署。
由于目前deploy阶段采用的runner是shell runner，使用的用户是gitlab-runner。可以理解为使用gitlab-runner用户登录到git.hupofin.tech这台机器上去，然后执行ci阶段里定义的命令。
所以我们需要给gitlab-runner配置一个kubectl客户端，这样一来，所有使用shell runner来执行ci的阶段都可以访问集群了
手动完成首次部署    首次部署应用到kubernetes不是本次的重点，可以参考kubernetes官网的交互式tutorial，很清晰。
Service Account    既然是在集群外远程访问控制集群，那么就需要一定的身份认证机制。这里采用Service Account的方式进行验证。
Service Account包括三个部分： namespace，token和CA证书。
所以我们需要做的就是在集群中创建一个新的sa用于部署，然后将上面三样东西配置在kubectl客户端就可以了。
创建一个新的SA    	kubectl create sa shaobo 获得secret的名字    	kubectl get sa shaobo -o json | jq -r .secrets[].name 	- shaobo-token-rq201 一个Service Account可以包含多个secret，例如刚刚我们创建一个新的SA时自动生成的secret就是用于访问API的secret。 同时，我们也可以自己定义其他的secret，例如在从私有registry下载镜像时可能会需要一个下载镜像的secret，使用https时需要相关证书的secret等等。"><meta property="og:title" content="在Gitlab-CI中设置kubectl实现自动部署"><meta property="og:description" content="参考文档     Kubernetes权威指南 How to Add Users to Kubernetes (kubectl)? Kubernetes Documentation  实现思路    Kubernetes集群主要由Master节点控制，Master节点又主要由其中的API Sever(kube-apiserver)提供Rest接口服务。所以我们大体思路就是在CI中配置好正确的kubectl客户端，使它能够直接连到部署的集群上，从而实现远程部署。
目前CI主要分为test, build, deploy等几个阶段，在build阶段就把新的image打包好并且上传到私有registry了，那么deploy阶段就只需要告诉kubernetes新的image编号，kubernetes就会自动帮我们下载新的镜像并且重新部署。
由于目前deploy阶段采用的runner是shell runner，使用的用户是gitlab-runner。可以理解为使用gitlab-runner用户登录到git.hupofin.tech这台机器上去，然后执行ci阶段里定义的命令。
所以我们需要给gitlab-runner配置一个kubectl客户端，这样一来，所有使用shell runner来执行ci的阶段都可以访问集群了
手动完成首次部署    首次部署应用到kubernetes不是本次的重点，可以参考kubernetes官网的交互式tutorial，很清晰。
Service Account    既然是在集群外远程访问控制集群，那么就需要一定的身份认证机制。这里采用Service Account的方式进行验证。
Service Account包括三个部分： namespace，token和CA证书。
所以我们需要做的就是在集群中创建一个新的sa用于部署，然后将上面三样东西配置在kubectl客户端就可以了。
创建一个新的SA    	kubectl create sa shaobo 获得secret的名字    	kubectl get sa shaobo -o json | jq -r .secrets[].name 	- shaobo-token-rq201 一个Service Account可以包含多个secret，例如刚刚我们创建一个新的SA时自动生成的secret就是用于访问API的secret。 同时，我们也可以自己定义其他的secret，例如在从私有registry下载镜像时可能会需要一个下载镜像的secret，使用https时需要相关证书的secret等等。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.mkdef.com/posts/%E5%9C%A8gitlab-ci%E4%B8%AD%E8%AE%BE%E7%BD%AEkubectl%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-04-08T15:29:39+08:00"><meta property="article:modified_time" content="2017-04-08T15:29:39+08:00"><title>在Gitlab-CI中设置kubectl实现自动部署 · Coder</title><link rel=canonical href=https://blog.mkdef.com/posts/%E5%9C%A8gitlab-ci%E4%B8%AD%E8%AE%BE%E7%BD%AEkubectl%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.96.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Coder</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://blog.mkdef.com/posts/%E5%9C%A8gitlab-ci%E4%B8%AD%E8%AE%BE%E7%BD%AEkubectl%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/>在Gitlab-CI中设置kubectl实现自动部署</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2017-04-08T15:29:39+08:00>April 8, 2017</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
One-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/kubernetes/>Kubernetes</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/gitlab/>Gitlab</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/devops/>DevOps</a></span></div></div></header><div><h2 id=参考文档>参考文档
<a class=heading-link href=#%e5%8f%82%e8%80%83%e6%96%87%e6%a1%a3><i class="fa fa-link" aria-hidden=true></i></a></h2><ol><li>Kubernetes权威指南</li><li><a href=http://stackoverflow.com/questions/42170380/how-to-add-users-to-kubernetes-kubectl>How to Add Users to Kubernetes (kubectl)?</a></li><li><a href=https://kubernetes.io/docs/home/>Kubernetes Documentation</a></li></ol><h2 id=实现思路>实现思路
<a class=heading-link href=#%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Kubernetes集群主要由Master节点控制，Master节点又主要由其中的API Sever(kube-apiserver)提供Rest接口服务。所以我们大体思路就是在CI中配置好正确的kubectl客户端，使它能够直接连到部署的集群上，从而实现远程部署。</p><p>目前CI主要分为test, build, deploy等几个阶段，在build阶段就把新的image打包好并且上传到私有registry了，那么deploy阶段就只需要告诉kubernetes新的image编号，kubernetes就会自动帮我们下载新的镜像并且重新部署。</p><p>由于目前deploy阶段采用的runner是shell runner，使用的用户是gitlab-runner。可以理解为使用gitlab-runner用户登录到git.hupofin.tech这台机器上去，然后执行ci阶段里定义的命令。</p><p>所以我们需要给gitlab-runner配置一个kubectl客户端，这样一来，所有使用shell runner来执行ci的阶段都可以访问集群了</p><h2 id=手动完成首次部署>手动完成首次部署
<a class=heading-link href=#%e6%89%8b%e5%8a%a8%e5%ae%8c%e6%88%90%e9%a6%96%e6%ac%a1%e9%83%a8%e7%bd%b2><i class="fa fa-link" aria-hidden=true></i></a></h2><p>首次部署应用到kubernetes不是本次的重点，可以参考kubernetes官网的交互式tutorial，很清晰。</p><h2 id=service-account>Service Account
<a class=heading-link href=#service-account><i class="fa fa-link" aria-hidden=true></i></a></h2><p>既然是在集群外远程访问控制集群，那么就需要一定的身份认证机制。这里采用Service Account的方式进行验证。</p><p>Service Account包括三个部分：
namespace，token和CA证书。</p><p>所以我们需要做的就是在集群中创建一个新的sa用于部署，然后将上面三样东西配置在kubectl客户端就可以了。</p><h3 id=创建一个新的sa>创建一个新的SA
<a class=heading-link href=#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e6%96%b0%e7%9a%84sa><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	kubectl create sa shaobo
</span></span></code></pre></div><h3 id=获得secret的名字>获得secret的名字
<a class=heading-link href=#%e8%8e%b7%e5%be%97secret%e7%9a%84%e5%90%8d%e5%ad%97><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	kubectl get sa shaobo -o json | jq -r .secrets[].name
</span></span><span style=display:flex><span>	- shaobo-token-rq201
</span></span></code></pre></div><p>一个Service Account可以包含多个secret，例如刚刚我们创建一个新的SA时自动生成的secret就是用于访问API的secret。
同时，我们也可以自己定义其他的secret，例如在从私有registry下载镜像时可能会需要一个下载镜像的secret，使用https时需要相关证书的secret等等。</p><h3 id=获取ca证书>获取CA证书
<a class=heading-link href=#%e8%8e%b7%e5%8f%96ca%e8%af%81%e4%b9%a6><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	kubectl get secret $secret -o json | jq -r &#39;.data[&#34;ca.crt&#34;]&#39; | base64 -d &gt; ca.crt
</span></span></code></pre></div><p>我们需要将<code>ca.crt</code>证书下载到CI服务器上去。</p><h3 id=获取token>获取token
<a class=heading-link href=#%e8%8e%b7%e5%8f%96token><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	kubectl get secret $secret -o json | jq -r &#39;.data[&#34;token&#34;]&#39; | base64 -d
</span></span></code></pre></div><h2 id=将api接口暴露到外网>将API接口暴露到外网
<a class=heading-link href=#%e5%b0%86api%e6%8e%a5%e5%8f%a3%e6%9a%b4%e9%9c%b2%e5%88%b0%e5%a4%96%e7%bd%91><i class="fa fa-link" aria-hidden=true></i></a></h2><h3 id=kubectl-proxy-搭建代理>kubectl proxy 搭建代理
<a class=heading-link href=#kubectl-proxy-%e6%90%ad%e5%bb%ba%e4%bb%a3%e7%90%86><i class="fa fa-link" aria-hidden=true></i></a></h3><p>kubernetes的API默认只有本机才能访问到的，所以我们首先需要搭建一个proxy，转发一下外网的请求，这里采用自带的<code>kubectl proxy</code></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	kubectl proxy --address=&#39;0.0.0.0&#39; --port=8001 --accept-hosts=&#39;^*$&#39;
</span></span></code></pre></div><p>这条命令实现了这么几个功能，监听8001端口，任何ip来源的请求，所有来源都准入。集群的准入准出通过阿里云的安全组策略控制，所有我们这里直接允许所有的请求即可。</p><h3 id=screen-后台运行>screen 后台运行
<a class=heading-link href=#screen-%e5%90%8e%e5%8f%b0%e8%bf%90%e8%a1%8c><i class="fa fa-link" aria-hidden=true></i></a></h3><p>然后为了保证proxy一直运行下去，通过<code>screen</code>命令保留到后台：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	screen kubectl proxy --address=&#39;0.0.0.0&#39; --port=8001 --accept-hosts=&#39;^*$&#39;
</span></span></code></pre></div><p><code>ctrl + a</code> <code>ctrl + d</code> detach，进程继续后台运行</p><h2 id=在新的机器上配置kubectl>在新的机器上配置kubectl
<a class=heading-link href=#%e5%9c%a8%e6%96%b0%e7%9a%84%e6%9c%ba%e5%99%a8%e4%b8%8a%e9%85%8d%e7%bd%aekubectl><i class="fa fa-link" aria-hidden=true></i></a></h2><h3 id=下载kubectl>下载kubectl
<a class=heading-link href=#%e4%b8%8b%e8%bd%bdkubectl><i class="fa fa-link" aria-hidden=true></i></a></h3><p><a href=https://kubernetes.io/docs/tasks/kubectl/install/>Installing and Setting Up kubectl</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>	<span style=font-style:italic># Linux</span>
</span></span><span style=display:flex><span>	curl -LO https://storage.googleapis.com/kubernetes-release/release/<span style=font-weight:700>$(</span>curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt<span style=font-weight:700>)</span>/bin/linux/amd64/kubectl
</span></span></code></pre></div><p>添加到用户目录里</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	chmod +x ./kubectl
</span></span><span style=display:flex><span>	sudo mv ./kubectl /usr/local/bin/kubectl
</span></span></code></pre></div><h3 id=设置cluster>设置cluster
<a class=heading-link href=#%e8%ae%be%e7%bd%aecluster><i class="fa fa-link" aria-hidden=true></i></a></h3><p>添加一个名字叫<code>hupo</code>的集群，server这里设置为集群的ip和端口：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	kubectl config set-cluster hupo --embed-certs=true --server=http://101.██.██.██:8081 --certificate-authority=./ca.crt
</span></span></code></pre></div><h3 id=设置user-credentials>设置user credentials
<a class=heading-link href=#%e8%ae%be%e7%bd%aeuser-credentials><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	kubectl config set-credentials shaobo --token=$token
</span></span></code></pre></div><h3 id=绑定cluster和用户>绑定cluster和用户
<a class=heading-link href=#%e7%bb%91%e5%ae%9acluster%e5%92%8c%e7%94%a8%e6%88%b7><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	kubectl config set-context hupo --cluster=hupo --user=shaobo --namespace=default
</span></span></code></pre></div><h3 id=切换到刚才设置的context>切换到刚才设置的context
<a class=heading-link href=#%e5%88%87%e6%8d%a2%e5%88%b0%e5%88%9a%e6%89%8d%e8%ae%be%e7%bd%ae%e7%9a%84context><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	kubectl config use-context hupo
</span></span></code></pre></div><h3 id=测试一下是否完成>测试一下是否完成
<a class=heading-link href=#%e6%b5%8b%e8%af%95%e4%b8%80%e4%b8%8b%e6%98%af%e5%90%a6%e5%ae%8c%e6%88%90><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	kubectl version
</span></span></code></pre></div><h2 id=ci里使用kubectl自动部署>CI里使用kubectl自动部署
<a class=heading-link href=#ci%e9%87%8c%e4%bd%bf%e7%94%a8kubectl%e8%87%aa%e5%8a%a8%e9%83%a8%e7%bd%b2><i class="fa fa-link" aria-hidden=true></i></a></h2><p>这里以loop-service为例，直接使用kubectl更新deployment的image设置即可。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>	kubectl set image deployment/loop-service loop-service=registry-vpc.cn-beijing.aliyuncs.com/hupofintech/loop-service:${ENV}-${CI_BUILD_REF:0:7}
</span></span></code></pre></div><p>这样做会有一个缺点，就是如果更新时服务会停止，且失败之后没有办法简单的回滚。更好的办法是采用Replication Controller实现滚动更新。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2022
无生
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.8fb86376a16e684af472a329aef502dbebcfab65ce264e9750d144912947c602.js integrity="sha256-j7hjdqFuaEr0cqMprvUC2+vPq2XOJk6XUNFEkSlHxgI="></script></body></html>