<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=content-language content="en">
<meta name=color-scheme content="light dark">
<meta name=author content="无生">
<meta name=description content="需求    两个需求：
 组里采购了一台服务器，托管在所里的机房里，但是到目前为止还没有分配外网ip，所以需要一个将本地端口暴露在外网的解决方案； 台式机是使用的所里的内网，但是本本用的路由。而且偶尔会需要离开工位，此时如果想用本本连到台式机，也需要将本地端口暴露到外网；  用过的解决方案，都是基于ngrok的：
国内的ngrok.cc，其实挺好用的，虽然速度上慢了一点。但是这次升级了版本之后，配置文件的写法没有公布出来，而且如果总是变的话也不是个长久的办法。加上这次服务器被攻击，直接关闭了三天免费服务器，这一点是无法容忍的。
原生的ngrok.io。配置比ngrok.cc要简单一点，但是服务器在美帝，更加慢了。免费版本随机出来的域名实在太难记了，而且每次都会变。并且不能绑定自己的域名，导致这个服务就今天拿来临时用了一下。
初步方案    自然还是用自己的服务器转发一下比较好。不过有两个问题，第一个是自己的服务器也不稳定，第二个是自己的服务器也在美帝。所以这个方案也只能是临时。但之后所里的服务器会有外网ip了，也就不需要这个服务了。其次，之后也许可以在所里的服务器上搭一个ngrok的server，这样就能以很快的速度登录到我的机器了(也许不能的原因是要绑定域名，而这个似乎很困难）
安装golang    sudo apt-get install build-essential sudo apt-get install golang sudo apt-get install mercurial 然而我的ubuntu版本似乎太低，安装好的go是1.0的。所以要自己安装高等级的版本，我这里安装的是1.6的版本。
sudo curl -O https://storage.googleapis.com/golang/go1.6.linux-amd64.tar.gz sudo tar -xvf go1.6.linux-amd64.tar.gz sudo mv go /usr/local 然后编辑profile，将go的路劲添加到系统路径里。然而我并没有成功。于是，我采用了很暴力的解决方案：
sudo ln -s /usr/local/go/bin/go /usr/bin/go 然后可以运行一下，查看是否安装成功:
go version 下载编译ngrok    git clone https://github.com/inconshreveable/ngrok.git ngrok cd ngrok 接下来，是生成自认证的证书，这里我直接引用人家的一段解释：
Once it has finished cloning ngrok to your local machine, there is yet another thing you will need to do before you can build and compile your very own ngrok server and client and that is to create your own self-signed SSL certificate and this is required because ngrok provides the secure tunnel via TLS and in order for both the client and server to work you will need to build and compile ngrok using your self signed SSL certificate and these are linked to each other.">
<meta name=keywords content="blog,developer,personal">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="建立自己的ngrok服务">
<meta name=twitter:description content="需求    两个需求：
 组里采购了一台服务器，托管在所里的机房里，但是到目前为止还没有分配外网ip，所以需要一个将本地端口暴露在外网的解决方案； 台式机是使用的所里的内网，但是本本用的路由。而且偶尔会需要离开工位，此时如果想用本本连到台式机，也需要将本地端口暴露到外网；  用过的解决方案，都是基于ngrok的：
国内的ngrok.cc，其实挺好用的，虽然速度上慢了一点。但是这次升级了版本之后，配置文件的写法没有公布出来，而且如果总是变的话也不是个长久的办法。加上这次服务器被攻击，直接关闭了三天免费服务器，这一点是无法容忍的。
原生的ngrok.io。配置比ngrok.cc要简单一点，但是服务器在美帝，更加慢了。免费版本随机出来的域名实在太难记了，而且每次都会变。并且不能绑定自己的域名，导致这个服务就今天拿来临时用了一下。
初步方案    自然还是用自己的服务器转发一下比较好。不过有两个问题，第一个是自己的服务器也不稳定，第二个是自己的服务器也在美帝。所以这个方案也只能是临时。但之后所里的服务器会有外网ip了，也就不需要这个服务了。其次，之后也许可以在所里的服务器上搭一个ngrok的server，这样就能以很快的速度登录到我的机器了(也许不能的原因是要绑定域名，而这个似乎很困难）
安装golang    sudo apt-get install build-essential sudo apt-get install golang sudo apt-get install mercurial 然而我的ubuntu版本似乎太低，安装好的go是1.0的。所以要自己安装高等级的版本，我这里安装的是1.6的版本。
sudo curl -O https://storage.googleapis.com/golang/go1.6.linux-amd64.tar.gz sudo tar -xvf go1.6.linux-amd64.tar.gz sudo mv go /usr/local 然后编辑profile，将go的路劲添加到系统路径里。然而我并没有成功。于是，我采用了很暴力的解决方案：
sudo ln -s /usr/local/go/bin/go /usr/bin/go 然后可以运行一下，查看是否安装成功:
go version 下载编译ngrok    git clone https://github.com/inconshreveable/ngrok.git ngrok cd ngrok 接下来，是生成自认证的证书，这里我直接引用人家的一段解释：
Once it has finished cloning ngrok to your local machine, there is yet another thing you will need to do before you can build and compile your very own ngrok server and client and that is to create your own self-signed SSL certificate and this is required because ngrok provides the secure tunnel via TLS and in order for both the client and server to work you will need to build and compile ngrok using your self signed SSL certificate and these are linked to each other.">
<meta property="og:title" content="建立自己的ngrok服务">
<meta property="og:description" content="需求    两个需求：
 组里采购了一台服务器，托管在所里的机房里，但是到目前为止还没有分配外网ip，所以需要一个将本地端口暴露在外网的解决方案； 台式机是使用的所里的内网，但是本本用的路由。而且偶尔会需要离开工位，此时如果想用本本连到台式机，也需要将本地端口暴露到外网；  用过的解决方案，都是基于ngrok的：
国内的ngrok.cc，其实挺好用的，虽然速度上慢了一点。但是这次升级了版本之后，配置文件的写法没有公布出来，而且如果总是变的话也不是个长久的办法。加上这次服务器被攻击，直接关闭了三天免费服务器，这一点是无法容忍的。
原生的ngrok.io。配置比ngrok.cc要简单一点，但是服务器在美帝，更加慢了。免费版本随机出来的域名实在太难记了，而且每次都会变。并且不能绑定自己的域名，导致这个服务就今天拿来临时用了一下。
初步方案    自然还是用自己的服务器转发一下比较好。不过有两个问题，第一个是自己的服务器也不稳定，第二个是自己的服务器也在美帝。所以这个方案也只能是临时。但之后所里的服务器会有外网ip了，也就不需要这个服务了。其次，之后也许可以在所里的服务器上搭一个ngrok的server，这样就能以很快的速度登录到我的机器了(也许不能的原因是要绑定域名，而这个似乎很困难）
安装golang    sudo apt-get install build-essential sudo apt-get install golang sudo apt-get install mercurial 然而我的ubuntu版本似乎太低，安装好的go是1.0的。所以要自己安装高等级的版本，我这里安装的是1.6的版本。
sudo curl -O https://storage.googleapis.com/golang/go1.6.linux-amd64.tar.gz sudo tar -xvf go1.6.linux-amd64.tar.gz sudo mv go /usr/local 然后编辑profile，将go的路劲添加到系统路径里。然而我并没有成功。于是，我采用了很暴力的解决方案：
sudo ln -s /usr/local/go/bin/go /usr/bin/go 然后可以运行一下，查看是否安装成功:
go version 下载编译ngrok    git clone https://github.com/inconshreveable/ngrok.git ngrok cd ngrok 接下来，是生成自认证的证书，这里我直接引用人家的一段解释：
Once it has finished cloning ngrok to your local machine, there is yet another thing you will need to do before you can build and compile your very own ngrok server and client and that is to create your own self-signed SSL certificate and this is required because ngrok provides the secure tunnel via TLS and in order for both the client and server to work you will need to build and compile ngrok using your self signed SSL certificate and these are linked to each other.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.mkdef.com/posts/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84ngrok%E6%9C%8D%E5%8A%A1/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2016-09-26T22:40:09+00:00">
<meta property="article:modified_time" content="2016-09-26T22:40:09+00:00">
<title>
建立自己的ngrok服务 · Coder
</title>
<link rel=canonical href=https://blog.mkdef.com/posts/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84ngrok%E6%9C%8D%E5%8A%A1/>
<link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin>
<link rel=stylesheet href=/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin=anonymous media=screen>
<link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16>
<link rel=apple-touch-icon href=/images/apple-touch-icon.png>
<link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png>
<meta name=generator content="Hugo 0.92.0">
</head>
<body class="preload-transitions colorscheme-auto">
<div class=float-container>
<a id=dark-mode-toggle class=colorscheme-toggle>
<i class="fa fa-adjust fa-fw" aria-hidden=true></i>
</a>
</div>
<main class=wrapper>
<nav class=navigation>
<section class=container>
<a class=navigation-title href=/>
Coder
</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle>
<i class="fa fa-bars fa-fw" aria-hidden=true></i>
</label>
<ul class=navigation-list>
<li class=navigation-item>
<a class=navigation-link href=/posts/>Blog</a>
</li>
<li class=navigation-item>
<a class=navigation-link href=/about/>About</a>
</li>
</ul>
</section>
</nav>
<div class=content>
<section class="container post">
<article>
<header>
<div class=post-title>
<h1 class=title>
<a class=title-link href=https://blog.mkdef.com/posts/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84ngrok%E6%9C%8D%E5%8A%A1/>
建立自己的ngrok服务
</a>
</h1>
</div>
<div class=post-meta>
<div class=date>
<span class=posted-on>
<i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2016-09-26T22:40:09Z>
September 26, 2016
</time>
</span>
<span class=reading-time>
<i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read
</span>
</div>
<div class=tags>
<i class="fa fa-tag" aria-hidden=true></i>
<span class=tag>
<a href=/tags/ngrok/>ngrok</a>
</span>
<span class=separator>•</span>
<span class=tag>
<a href=/tags/dns/>DNS</a>
</span>
<span class=separator>•</span>
<span class=tag>
<a href=/tags/go/>go</a>
</span>
<span class=separator>•</span>
<span class=tag>
<a href=/tags/ubuntu/>ubuntu</a>
</span></div>
</div>
</header>
<div>
<p><img src=/uploads/GO_16.png alt></p>
<h2 id=需求>
需求
<a class=heading-link href=#%e9%9c%80%e6%b1%82>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>两个需求：</p>
<ol>
<li>组里采购了一台服务器，托管在所里的机房里，但是到目前为止还没有分配外网ip，所以需要一个将本地端口暴露在外网的解决方案；</li>
<li>台式机是使用的所里的内网，但是本本用的路由。而且偶尔会需要离开工位，此时如果想用本本连到台式机，也需要将本地端口暴露到外网；</li>
</ol>
<p>用过的解决方案，都是基于ngrok的：</p>
<p>国内的ngrok.cc，其实挺好用的，虽然速度上慢了一点。但是这次升级了版本之后，配置文件的写法没有公布出来，而且如果总是变的话也不是个长久的办法。加上这次服务器被攻击，直接关闭了三天免费服务器，这一点是无法容忍的。</p>
<p>原生的ngrok.io。配置比ngrok.cc要简单一点，但是服务器在美帝，更加慢了。免费版本随机出来的域名实在太难记了，而且每次都会变。并且不能绑定自己的域名，导致这个服务就今天拿来临时用了一下。</p>
<h2 id=初步方案>
初步方案
<a class=heading-link href=#%e5%88%9d%e6%ad%a5%e6%96%b9%e6%a1%88>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>自然还是用自己的服务器转发一下比较好。不过有两个问题，第一个是自己的服务器也不稳定，第二个是自己的服务器也在美帝。所以这个方案也只能是临时。但之后所里的服务器会有外网ip了，也就不需要这个服务了。其次，之后也许可以在所里的服务器上搭一个ngrok的server，这样就能以很快的速度登录到我的机器了(也许不能的原因是要绑定域名，而这个似乎很困难）</p>
<h3 id=安装golang>
安装golang
<a class=heading-link href=#%e5%ae%89%e8%a3%85golang>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo apt-get install build-essential
sudo apt-get install golang
sudo apt-get install mercurial
</code></pre></div><p>然而我的<code>ubuntu</code>版本似乎太低，安装好的go是1.0的。所以要自己安装高等级的版本，我这里安装的是1.6的版本。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo curl -O https://storage.googleapis.com/golang/go1.6.linux-amd64.tar.gz
sudo tar -xvf go1.6.linux-amd64.tar.gz
sudo mv go /usr/local
</code></pre></div><p>然后编辑profile，将go的路劲添加到系统路径里。然而我并没有成功。于是，我采用了很暴力的解决方案：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo ln -s /usr/local/go/bin/go /usr/bin/go
</code></pre></div><p>然后可以运行一下，查看是否安装成功:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>go version
</code></pre></div><h3 id=下载编译ngrok>
下载编译ngrok
<a class=heading-link href=#%e4%b8%8b%e8%bd%bd%e7%bc%96%e8%af%91ngrok>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git clone https://github.com/inconshreveable/ngrok.git ngrok
cd ngrok
</code></pre></div><p>接下来，是生成自认证的证书，这里我直接引用人家的一段解释：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Once it has finished cloning ngrok to your local machine, there is yet another thing you will need to do before you can build and compile your very own ngrok server and client and that is to create your own self-signed SSL certificate and this is required because ngrok provides the secure tunnel via TLS and in order for both the client and server to work you will need to build and compile ngrok using your self signed SSL certificate and these are linked to each other. So you cannot connect to your self-signed ngrokd server via the official ngrok client as both the server and client need to be signed using the same certificate.
</code></pre></div><p>然后是生成证书的命令，需要将<code>NGROK_BASE_DOMAIN</code>替换成自己的域名，例如我的就是"tunnel.mkdef.com"。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>openssl genrsa -out base.key 2048
openssl req -new -x509 -nodes -key base.key -days 10000 -subj <span style=font-style:italic>&#34;/CN=[NGROK_BASE_DOMAIN]&#34;</span> -out base.pem
openssl genrsa -out server.key 2048
openssl req -new -key server.key -subj <span style=font-style:italic>&#34;/CN=[NGROK_BASE_DOMAIN]&#34;</span> -out server.csr
openssl x509 -req -in server.csr -CA base.pem -CAkey base.key -CAcreateserial -days 10000 -out server.crt
</code></pre></div><p>然后需要去托管域名的网站添加一条解析规则，例如我托管在DNSpod上了。
最后终于可以编译了！！！</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cp base.pem assets/client/tls/ngrokroot.crt
make release-server release-client
</code></pre></div><p>生成的服务端和客户端在<code>bin</code>目录下。</p>
<h2 id=运行测试>
运行测试
<a class=heading-link href=#%e8%bf%90%e8%a1%8c%e6%b5%8b%e8%af%95>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<h3 id=服务端>
服务端
<a class=heading-link href=#%e6%9c%8d%e5%8a%a1%e7%ab%af>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>./ngrokd -tlsKey=server.key -tlsCrt=server.crt -domain=<span style=font-style:italic>&#34;[NGROK_BASE_DOMAIN]&#34;</span> -httpAddr=<span style=font-style:italic>&#34;:8080&#34;</span> -httpsAddr=<span style=font-style:italic>&#34;:8081&#34;</span>
</code></pre></div><p>然后打开浏览器，访问一下你配置的网站就好了，例如“http://tunnel.mkdef.com:8080”。
看到提示说<code>Tunnel not found</code>就表示成功了。</p>
<h3 id=客户端>
客户端
<a class=heading-link href=#%e5%ae%a2%e6%88%b7%e7%ab%af>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3>
<p>首先编写配置文件<code>ngrok.cfg</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cfg data-lang=cfg>server_addr: [NGROK_BASE_DOMAIN]:4443
trust_host_root_certs: false
</code></pre></div><p>然后执行</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>./ngrok -subdomain testing -config=ngrok.cfg 80
</code></pre></div><p>这样你就能通过 <code>testing.tunnel.mkdef.com:8080</code> 来访问你本地的80端口了。</p>
<p>如果是tcp连接，执行</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>./ngrok -config=ngrok.cfg -proto tcp 22
</code></pre></div><p>这是会显示出一个端口，似乎是随机的，不过好在反复执行是不变的，然后通过这个端口就能登录到你的本地机器了。没有测试多次执行是什么情况。</p>
<h2 id=todo>
TODO
<a class=heading-link href=#todo>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p>目前为止只解决了部分需求，因为这个新的外网网址实在太长了，而且端口不是默认端口，所以至少还需要一步端口转发。</p>
<h2 id=reference>
Reference
<a class=heading-link href=#reference>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2>
<p><a href=https://www.digitalocean.com/community/tutorials/how-to-install-go-1-6-on-ubuntu-14-04>How To Install Go 1.6 on Ubuntu 14.04</a></p>
<p><a href=https://www.svenbit.com/2014/09/run-ngrok-on-your-own-server/>Run Ngrok on Your Own Server Using Self-Signed SSL Certificate</a></p>
</div>
<footer>
</footer>
</article>
</section>
</div>
<footer class=footer>
<section class=container>
©
2016 -
2022
无生
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.
</section>
</footer>
</main>
<script src=/js/coder.min.39a51230dce2ac866c049b52573e38bf60666af4bc63c1bdf203b9b2d95b1cd6.js integrity="sha256-OaUSMNzirIZsBJtSVz44v2BmavS8Y8G98gO5stlbHNY="></script>
</body>
</html>