<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jquery on Coder</title><link>https://blog.mkdef.com/tags/jquery/</link><description>Recent content in Jquery on Coder</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 20 Jun 2016 13:46:52 +0800</lastBuildDate><atom:link href="https://blog.mkdef.com/tags/jquery/index.xml" rel="self" type="application/rss+xml"/><item><title>Odes（二）页面设计与实现</title><link>https://blog.mkdef.com/posts/odes%E4%BA%8C%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 20 Jun 2016 13:46:52 +0800</pubDate><guid>https://blog.mkdef.com/posts/odes%E4%BA%8C%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid><description>整体结构 网站按照之前在Everstring常用的前后端结构，后端只提供api，前端一个html从后端请求数据然后展示，用nginx讲两者的流量区分开来。本来前端需要gulp配置一通流水线工具的，但是折腾了一天也没有弄出个样子来，干脆放弃这些高端玩意，先把东西用最原始最简单的方法做出来，有需求了才有动力换新的方法。
后端实现 由于目前只有一个展示诗文正文的一个页面，所以api非常简单。一开始的版本如下：
@app.route(&amp;#34;/odes-api/&amp;lt;int:id&amp;gt;&amp;#34;) def get_ode_by_id(id): script = &amp;#34;&amp;#34;&amp;#34; WITH s AS (SELECT * FROM odes where id = %s) SELECT row_to_json(s) FROM s; &amp;#34;&amp;#34;&amp;#34; cu.execute(script, (id,)) res = cu.fetchall() if res is None: raise ValueError else: return jsonify(res[0]) 请求一个id的数据，把对应诗文的内容和相关的一些数据全部传输过去。这里错误处理暂时没有实现。
后来为了实现上一篇和下一篇的功能，考虑了一番决定还是通过这一个api把相邻两个诗文的数据一并传输过去，对应的sql语句为：
WITH s AS (SELECT * FROM odes where id in (%s, %s, %s)) SELECT array_to_json(array_agg(row_to_json(s))) FROM s; 这样一来，问题就在于前端如何知道哪个数据是自己的，哪个数据是相邻页面的，于是手工调整顺序，将请求的数据放在中间。于是丑陋的代码实现如下：</description></item></channel></rss>