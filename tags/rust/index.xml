<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on Coder</title><link>https://blog.mkdef.com/tags/rust/</link><description>Recent content in Rust on Coder</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 31 Mar 2022 11:49:28 +0800</lastBuildDate><atom:link href="https://blog.mkdef.com/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Wordle优化</title><link>https://blog.mkdef.com/posts/wordle%E4%BC%98%E5%8C%96/</link><pubDate>Thu, 31 Mar 2022 11:49:28 +0800</pubDate><guid>https://blog.mkdef.com/posts/wordle%E4%BC%98%E5%8C%96/</guid><description>结果 目前的代码能通过可以被认为是作弊的方法得到hard模式下的最优解： 初始词 salet, 一共猜测8116次，最多的单词猜7次。
如果需要证明这是最优的，需要遍历所有的单词，枚举所有的可能步骤。这需要大量的时间。不过能力有限，我打算就到此为止了，本文会简单的记录我所发现和使用的一些优化方法。
起点 前文已经给出了目标解的形式，一棵决策树，节点是猜测的单词，状态是转移条件。同时，这棵树是具有最优子结构的。
best[guess] = min(sum(best[next_guess], pattern for next_guess)) for next_guess in all available guesses 从形式上来说，具备树形dp的一切条件。不过这并没有太多改善，因为每一步的状态转移可能性仍然有12000种，而我们也看到最优解最深需要猜7次。这个复杂度是不能接受的。
用整数表示状态 其实这个优化我在很晚才做，虽然这个优化是显然的，不管时间还是空间上，都会得到很大的改善。
但是它会导致状态丧失直观性，我几乎没有办法用肉眼检查计算是否正确。不过多亏了Rust严格的编译期检查，我在后期还算简单地完成了这个修改。
pub fn check(target: &amp;amp;str, guess: &amp;amp;str) -&amp;gt; u8 { let mut freq = BTreeMap::&amp;lt;char, usize&amp;gt;::new(); for (guess_c, target_c) in guess.chars().zip(target.chars()) { if guess_c != target_c { let counter = freq.entry(target_c).or_insert(0); *counter += 1; } } let mut pattern: u8 = 0; let mut base: u8 = 1; for (guess_c, target_c) in guess.</description></item></channel></rss>