<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Wordle on Coder</title><link>https://blog.mkdef.com/tags/wordle/</link><description>Recent content in Wordle on Coder</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 31 Mar 2022 11:49:28 +0800</lastBuildDate><atom:link href="https://blog.mkdef.com/tags/wordle/index.xml" rel="self" type="application/rss+xml"/><item><title>Wordle优化</title><link>https://blog.mkdef.com/posts/wordle%E4%BC%98%E5%8C%96/</link><pubDate>Thu, 31 Mar 2022 11:49:28 +0800</pubDate><guid>https://blog.mkdef.com/posts/wordle%E4%BC%98%E5%8C%96/</guid><description>结果 目前的代码能通过可以被认为是作弊的方法得到hard模式下的最优解： 初始词 salet, 一共猜测8116次，最多的单词猜7次。
如果需要证明这是最优的，需要遍历所有的单词，枚举所有的可能步骤。这需要大量的时间。不过能力有限，我打算就到此为止了，本文会简单的记录我所发现和使用的一些优化方法。
起点 前文已经给出了目标解的形式，一棵决策树，节点是猜测的单词，状态是转移条件。同时，这棵树是具有最优子结构的。
best[guess] = min(sum(best[next_guess], pattern for next_guess)) for next_guess in all available guesses 从形式上来说，具备树形dp的一切条件。不过这并没有太多改善，因为每一步的状态转移可能性仍然有12000种，而我们也看到最优解最深需要猜7次。这个复杂度是不能接受的。
用整数表示状态 其实这个优化我在很晚才做，虽然这个优化是显然的，不管时间还是空间上，都会得到很大的改善。
但是它会导致状态丧失直观性，我几乎没有办法用肉眼检查计算是否正确。不过多亏了Rust严格的编译期检查，我在后期还算简单地完成了这个修改。
pub fn check(target: &amp;amp;str, guess: &amp;amp;str) -&amp;gt; u8 { let mut freq = BTreeMap::&amp;lt;char, usize&amp;gt;::new(); for (guess_c, target_c) in guess.chars().zip(target.chars()) { if guess_c != target_c { let counter = freq.entry(target_c).or_insert(0); *counter += 1; } } let mut pattern: u8 = 0; let mut base: u8 = 1; for (guess_c, target_c) in guess.</description></item><item><title>Wordle</title><link>https://blog.mkdef.com/posts/wordle/</link><pubDate>Wed, 16 Mar 2022 14:48:07 +0800</pubDate><guid>https://blog.mkdef.com/posts/wordle/</guid><description>起因 在B站上看了3b1b的科普视频，介绍了wordle游戏中的一些信息论原理。在视频里，作者实现了一个solver，并且直观地介绍了它的原理。不过在视频的结尾提到了通过多探索一步，提升了solver的效果。当时看到这里我就在想，难道这个方法并不是最优解？很快就能发现，视频中的每一步guess，都是基于当前的最优值，所以这只是一个简单的贪心算法，很可能不是最优的。当然，视频的主要目的还是直观的介绍信息熵等概念，解法是不是最优并不重要。
后来，我在评论中看到了一个Leader Board, 里面给出了最优解，并且提供了一些解法自己的介绍链接. 然后通过这个名单，我才发现这个Wordle这个游戏还有Hard模式，然后Hard模式的平均猜测次数‘理所当然地’比普通模式的多。然而，后面发现，这里其实提示了一个非常大的坑，这个坑会导致普通模式错过最优解，具体关于这个坑的介绍在本文的最后面。
游戏介绍 Wordle 的游戏规则很简单，玩家每次猜测一个包含5个字母的单词，然后游戏会反馈一个结果，这个结果也包含5位，每个位置有三种颜色，绿色表示该字母正确且位置正确，黄色表示字母正确但是位置不对，灰色表示答案不包含这个字母，最后要求玩家在5次内猜到出这个单词。
思考了一下这个玩法，很容易联想到以前玩过的小游戏猜数字，每次猜测一个四位数字，游戏返回结果XAXB，A代表有几个位置数字和位置都正确，B代表猜对了数字，但是位置不对。
比较这两个游戏，有三个地方是明显的区别：
结果的pattern不一样 猜测的字符wordle可以重复，猜数字不能 wordle要求猜测的5个字符是一个valid的单词，而猜数字没有限制 但是这些区别都不本质，我们可以很容易地把这两个游戏抽象成一个游戏。
首先，定义一个游戏猜测的全集，对于wordle来说，是5个字母的单词表，对于猜数字来说，是所有的4位数字。 玩家给出一个猜测，游戏根据规则的不同会反馈不同的pattern，事实上这可以看做将当前所有可能的结果，根据pattern过滤出符合反馈的，缩小下一轮的猜测范围。 最后不断重复上一个步骤，直到pattern满足胜利条件。 需要注意的是，按照这种模式，给出新的猜测仅与当前可能的结果有关，与之前的猜测和反馈都没有关系。 所以基于这种交互，我们可以定义两个类 Checker 和 Solver :
Checker 相当于游戏的裁判，每一轮的结果以及游戏是否结束都是Checker说了算. Solver 相当于玩家，每一轮根据当前可能的猜测范围提供一个guess，然后根据Checker反馈的结果更新猜测范围。
class Checker: # 根据 target 计算当前 guess 的结果 def check(self, target: str, guess: str) -&amp;gt; str: pass def is_success(self, pattern) -&amp;gt; bool: pass class Solver: def guess(self) -&amp;gt; str: pass def update(self, guess: str, pattern: str): pass 评估策略 想要比较解法的好坏，首先需要合理地评价一个解法。这个游戏通常有两个维度来评价：</description></item></channel></rss>