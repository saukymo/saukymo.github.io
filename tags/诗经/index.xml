<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>诗经 on Coder</title><link>https://blog.mkdef.com/tags/%E8%AF%97%E7%BB%8F/</link><description>Recent content in 诗经 on Coder</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 20 Jun 2016 13:46:52 +0800</lastBuildDate><atom:link href="https://blog.mkdef.com/tags/%E8%AF%97%E7%BB%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>Odes（二）页面设计与实现</title><link>https://blog.mkdef.com/posts/odes%E4%BA%8C%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 20 Jun 2016 13:46:52 +0800</pubDate><guid>https://blog.mkdef.com/posts/odes%E4%BA%8C%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid><description>整体结构 网站按照之前在Everstring常用的前后端结构，后端只提供api，前端一个html从后端请求数据然后展示，用nginx讲两者的流量区分开来。本来前端需要gulp配置一通流水线工具的，但是折腾了一天也没有弄出个样子来，干脆放弃这些高端玩意，先把东西用最原始最简单的方法做出来，有需求了才有动力换新的方法。
后端实现 由于目前只有一个展示诗文正文的一个页面，所以api非常简单。一开始的版本如下：
@app.route(&amp;#34;/odes-api/&amp;lt;int:id&amp;gt;&amp;#34;) def get_ode_by_id(id): script = &amp;#34;&amp;#34;&amp;#34; WITH s AS (SELECT * FROM odes where id = %s) SELECT row_to_json(s) FROM s; &amp;#34;&amp;#34;&amp;#34; cu.execute(script, (id,)) res = cu.fetchall() if res is None: raise ValueError else: return jsonify(res[0]) 请求一个id的数据，把对应诗文的内容和相关的一些数据全部传输过去。这里错误处理暂时没有实现。
后来为了实现上一篇和下一篇的功能，考虑了一番决定还是通过这一个api把相邻两个诗文的数据一并传输过去，对应的sql语句为：
WITH s AS (SELECT * FROM odes where id in (%s, %s, %s)) SELECT array_to_json(array_agg(row_to_json(s))) FROM s; 这样一来，问题就在于前端如何知道哪个数据是自己的，哪个数据是相邻页面的，于是手工调整顺序，将请求的数据放在中间。于是丑陋的代码实现如下：
if (id == 1): res[0][0], res[0][1], res[0][2] = res[0][2], res[0][0], res[0][1] if (id == MAXID): res[0][0], res[0][1], res[0][2] = res[0][1], res[0][2], res[0][0] 但是这样会出现几个问题，第一个是顺序是由postgres默认决定的，程序没有做校验，也没有办法校验（各个数据一致，没有字段标识区别开），正确结果依赖于各个部分默契合作，这样显然是不合理的。第二个是传输查询的内容过多，然而很多信息是毫无必要的，减慢了页面的加载速度。所以重新设计如下：第一，不采用循环的方式，第一篇没有上一篇，最后一篇没有下一篇(一方面处理逻辑要简单很多，更主要的是这个功能确实无所谓)。第二，分两次查询，因为查询是在服务器本地进行的，查询两次代价并不大，第二次仅仅查询相邻篇章的标题。代码如下：</description></item><item><title>Odes（一）爬取全文</title><link>https://blog.mkdef.com/posts/odes%E4%B8%80%E7%88%AC%E5%8F%96%E5%85%A8%E6%96%87/</link><pubDate>Thu, 16 Jun 2016 10:02:25 +0800</pubDate><guid>https://blog.mkdef.com/posts/odes%E4%B8%80%E7%88%AC%E5%8F%96%E5%85%A8%E6%96%87/</guid><description>项目想法 因为一直没有一个比较完整的项目，所以想参考变卦做一个小的project，展示一个内容有限但是比较有意思的东西，顺便学习实践一下前端技术，于是就选择了诗经。内容不多，一共也就305首。一共分成3个步骤吧，第一步找个网站抓一个比较完整的全文下来，整理好之后存放到数据库里，第二步写一个前端把内容展示出来，但是这边是前后端配合还是单独一个前端页面还没有想好。第三步是其他功能的加入，比如注音和释义，甚至其他的一些比如统计数据之类的功能。
时间安排上并没有计划，主要最近空闲时间比较多，又不想复习，于是才想做这么个项目。反正先把坑挖在这，什么时候能做完就只能随缘了。
postgres安装和配置 其实这一部并不一定需要，因为内容确实不多，直接做成静态页面效果也不错。主要是为了之后第三部可能会需要比较复杂的功能时提前准备。但是没想到这一部花了比较多的时间，最后也只是能用，并没有设置成一个正常的状态。
postgres安装 按照各类教程中的内容，只需要这一步就可以安装好数据库并且自动开启服务，端口5432。
sudo apt-get install postgresql 但是执行完之后，psql并没有连上数据库，服务器上也看不到postgres的进程。
略去中间大量的搜索和尝试的过程，在/usr/lib/postgresql/9.1/bin/目录里找到常用的命令，于是按照手动启动数据库的方式启动：
/usr/lib/postgresql/9.1/bin/postgres -D ~/data 这里提示我不能用root权限开启服务，恍然大悟，之前没有成功启动的原因可能就是因为我一直使用的root用户(使用的服务器虽然用了很长一段时间了，但是当时仅仅安装了一个wordpress就没有登上去过了。所以一直都是root用户。)但是它为什么没有任何提示呢？！于是得到一个教训，新服务器第一件事就是建立一个新的非root用户。建了一个新的用户saukymo之后，终于成功开启了服务。
之后的过程由于大量试错，现在不能准确回忆起来了，不过应该还是通过这个目录下的initdb和createdb成功建立了一个数据库odes。
在Mac中，可以通过brew安装，安装完成之后就可以使用psql了，之后也能安装psycopg2的python库了。
brew install postgresql 直接使用psql命令进入数据库，然后给用户设置密码：
\password saukymo Postgres允许远程连接 默认情况下，只允许本机连接数据库，如果需要远程连接到数据库，需要设置postgres允许远程连接。设置比较简单，首先修改data目录下的pg_hba.conf文件，加入一行
host all all 0.0.0.0/0 md5 这样就能允许所有的ip通过密码访问数据库了。
然后修改postgresl.conf文件，设置listen_addresses为任意即可，即：
listen_addresses = &amp;#39;*&amp;#39; 然后重启服务，我这里因为安装方式不太正确，命令为：
/usr/lib/postgresql/9.1/bin/pg_ctl -D ~/data restart 此时就能在其他机器上连接上数据库了，完整的psql命令为：
psql -U saukymo -h ▇▇.▇▇.▇▇.▇▇ -d odes -W 按照提示输入之前设置的密码即可。
安装psycopg2 这个库是python用来连接postgres数据库的，通过pip安装即可
pip install psycopg2 需要注意的是，这个库并不能兼容Pypy，如果需要和Pypy一起工作的话，需要安装psycopg2cffi，简单设置之后，就可以兼容了，而且原来的代码不需要变化。</description></item></channel></rss>